# ПОВЕДЕНЧЕСКИ ШАБЛОНИ

## Behavioral patterns

Целта на тези шаблони е да спомагат комуникацията/взаимодействието между обектите. Отговарят също и за възлагането на отговорности между обектите или енкапсулирането на поведение в обект делегирането на изпълнение. Увеличават гъвкавостта и се грижат за комуникацията между класовете.

### Основни поведенчески шаблони

- Chain of Responsibility
- Iterator
- Template Method
- Strategy
- Command
- Observer
- Mediator
- Memento
- Visitor
- State
- Interpreter
- Specification

## Chain of Responsibility

Този шаблон ни позволява да предадем молба от обект към следващ обект, докато молбата бива удовлетворена. Пример за това е прихващането на грешки, където ако грешката не е за текущия се прехвърля към по-старшия. По този начин се опростяват взаимовръзките между обектите. Отговорността е в дървовидна структура. Специфичното за тази структура е, че изпращача знае за само един получател. Получателят знае само за следващия получател, но не и за предходният изпращач. Първия получател, който има правомощие да се справи със задачата прекъсва веригата. Подредбата на обектите във веригата има значение. След разглеждането на структурните шаблони и шаблоните, които служат за създаване на обекти на пръв поглед започват да се появяват прилики. Примерно Chain of Reasonability прилича на Decorator, Composite, Proxy и е възможно първоначално да се объркаме, кога е нужно да се използва един или друг. 

Нека разгледаме следното сравнение: Decorator vs. Composite vs. Chain Of Responsibility vs. Proxy pattern.

**Composite** се използва, когато трябва да се създаде дървовидна структура, която е подобна на граф и трябва да се обходи рекурсивно. Т.е. при него имаме компоненти, които са или съставна част, т.е. composite, или са „листо“.

**Decorator** от своя страна изглежда много подобен на Composite, но в същото време е с напълно различна цел. Основната разлика между Composite и Decorator е размножението. Decorator-а има само един следващ обект след него, но също може да декорира други обект рекурсивно. Целта на Decorator шаблона е да промени входящите заявки и да ги препрати към наследниците си. Т.е. с него заявките първо се декорират преди да се изпратят към наследниците. 

**Chain of Responisibility** е много подобен на Decorator, но разликата е в това, че операцията може да спре на всеки един обект, които участва във веригата, но трябва да изпълнява търсеното условие.

**Proxy** е също много подобен на Decorator само, че може да има само едно Proxy преди изискването да пристигне към листото. Т.е. при този шаблон не може както при Decorator-a да имаме обект, които води към друг обект.

UML диаграма:
![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/ChainOfResponsibility.png "Chain of Resposibility Pattern")

## Iterator Pattern

Осигурява ни начин за достъпване на елементи от обект последователно. Без да се налага да се показва вътрешната репрезентация. UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/Iterator.gif "Iterator Pattern")

Участниците в този шаблон са:

-Iterator(Abstractor) – осигурява интерфейс за достъп и обхождане на елемнти
-ConcreteIterator(Iterator) – наследява Iterator и имплементира неговите интерфейси. Запазва състояние за конкретната позиция.
-Agregate (AbastractCollection) – дефинира интерфейс за създаване на Iterator обект
-ConcreteAggregate (Collection) – имплементира създаването на итератор, за да върне правилната инстанция на ConcreteIterator. 

В .NET итератор шаблона се ползва в IEnumerable. 

Често се среща при разработката са да се ползва колекция от обекти. Ако имаме колекция от обекти ще ни се наложи да обхождаме по някакъв начин тези обекти. Повечето езици осигуряват вградени начини за обхождане ако се ползват вградени типове колекции – List, LinkedList и др. Тези „контейнери“ на обекти ни позволяват да обхождаме обектите. Именно класовете на тези колекции са най-доброто обяснение за Iterator шаблона.

Идеята за Iterator шаблона е, че се разкача самата колекция от обекти от логиката за обхождане. Това позволява обекта на колекцията да е по-малък, защото няма нужда да се занимава със свързаните функционалности за обхождане. От гледна точка на клиента има и ясно разграничение между самата колекция и начина, по който се обхожда колекцията. Също и клиента не трябва да се занимава със следеното на броя обиколени обекти и колко още не са обиколени.

## Template Method Pattern

Има случай, в които от алгоритъма се иска да изпълни даден процес, но същината на процеса или конкретния алгоритъм може да варира. Примерно може да се използвам различни алгоритми за търсене или сортиране в зависимост от предоставената информация. Такива сценарии могат да разработва използвайки и Strategy шаблона. Разликата спрямо Strategy е, че при Template Method може да се запазват същите алгоритми, но с леки изменения в процесите, които следват. Template метод шаблона е полезен в случай, в които има алгоритъм и някаква малка част от алгоритъма варира.  UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/TemplateMethod.jpg " Template Method")

На диаграмата може да се види, че шаблона се състои от два класа:

**AbstractClass**:  Този клас се състои от два типа методи. Първо съдържа един метод, който държи всяка стъпка от алгоритъма. Втория метод от класа е така наречения Template Method. Този метод държи всички индивидуални методи и осигурява скелет за изпълнение на алгоритъма.

**ConcreteClass**: Този клас презаписва методите, които се осигуряват от абстрактния за всяка стъпка. Тук се съдържа конкретната имплементация на отделната стъпка.

## Strategy Pattern

Този шаблон дефинира „семейство от алгоритми“, енкапсулира всеки от тях и ги прави взаимнозаменяеми. По този начин се дава възможност на клиент да ги използва независимо. Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/Strategy.gif "Strategy Pattern")

**„Семейство от алгоритми“ ** - това означава, че имаме функционалност в тези алгоритми, която получава еднакъв резултат след изпълнение, но получаването на резултата се случва по различен начин. Т.е. алгоритъма се изпълнява по различен начин.

** „Енкапсулира всеки един от тях“ ** - т.е. всеки един отделен алгоритъм ще бъде разположен в отделен клас и така ще се енкапсулира. По този начин ще имаме възможност да изберем отделен алгоритъм спрямо нуждите ни.

** „Прави ги взаимнозаменяеми“ ** - това удобство ни дава възможност да избираме по време на изпълнение кой от наличните алгоритми да използваме.

Най-често използвания пример за обяснение на този шаблон  е алгоритъма за сортиране. В зависимост от различните данни, които трябва да се сортират могат да се използват различни алгоритми за сортиране, защото всеки един от тях си има своите плюсове и минуси. 

## Command Pattern

Обект, който енкапсулира цялата информация, която е нужна, за да се извика метод на по-късен етап. Чрез него се разделя клиента, които изпълнява командата от детайлите.  Сходни шаблони са Factory Pattern, Null Object, Composite. По реален пример е ситуация, в която се налага върху даден обект да се направят няколко операции. Т.е. потребителя има възможност да изпълни една или няколко операции от възможните.  Command pattern-a енкапсулира всички заявки идващи от обекта и ги изпраща към получателя и позволява на получателя да предприеме действие. Ако трябва да се изпълнят много действия може да имаме йерархия от команди, които трябва да се изпълнят.  Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/CommandPattern.jpg "Command Pattern")

Реален пример, при който може да се използва този шаблон е калкулатора.  Най-важното нещо, което е характерно за този шаблон е, че Command-а служи като връзка между изпращач и получател. Той трябва само да казва на получателя каква задача трябва да се изпълни и по никакъв начин не трябва да се намесва между логиката на изпълнение между изпращаш и получател. 

## Observer Pattern

Шаблона Observer определя връзка тип едно-към-много между различни обекти. Когато един обект си смени състоянието, всички наблюдатели, които са „абонирани“ да получават информация при промяна биват уведомени. Има разделение между обект и наблюдаващ.  Предоставя се интерфейс посредством, които се дава възможност за комуникация без да се споделят детайли. Модела е познат също като Publish-Subscribe, в C# този модел се използва са event-и.  

Кога може да се използва? Много пъти се налага една част от дадено приложение да получава информация за обновление някаква друга част на приложението. Един от начините това да се случва е получателя на съобщението регулярно да проверява дали е пристигнало, но този подход има твърде много проблеми. Първото нещо е, че се консумира твърде много процесорно време за проверки и второ сме обвързани с интервала на проверката, което значи, че има период, в който може да се подаде невярна информация.  Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/ObserverPattern.jpg "Observer Pattern")

От какво се състои шаблона:

**Subject** - този клас служи за запазване на информация за наблюдаващите. Има възможност да добавя и маха наблюдаващи. Другата задача на този клас е да има метод, чрез които информира абонатите при настъпване на дадено събитие.

**ConcreteSubject** - Това е реален клас, който е имплементирал Subject. 

**Observer** - това е класа за наблюдаващи, в който има дефиниран метод и той се изпълнява, когато настъпи дадено събитие

**ConcreteObserver** - този клас имплементира Observer и изпълнява даден метод при настъпване на събитие.

В C# имаме улеснение при използването на този шаблон, защото там могат да се използват делегати, които са реално много добър пример за ползването на Observer шаблона.

## Memento Pattern

Характерното за този шаблон е, че запазва и има възможност да възстанови вътрешното състояние на обект. По-елементарен пример, но не и за реализация, е Photoshop history, в което имате Undo опция и може да се връщаме назад. В най-различни приложения имаме опциите Undo/Redo и именно те са идеален пример, в който имаме приложение на използването на шаблона Memento.  Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/MementoPattern.PNG "Memento Pattern")

Класа **Originator** е обекта, който ще бъде записван и възстановяван в последствие. В променливата **state** се записва информация за състоянието на обекта. Метода **CreateMemento** служи за записване на текущото състояние.  Метода **SetMemento** служи за възстановяване на състоянието.

## Mediator Pattern

Опростява комуникацията между обектите в приложението с използването на централизиран компонент, който се нарича – Mediator. Дефинира обект, които енкапсулира в себе си информация за това как обектите взаимодействат един с друг, но без тези обект да имат знание един за друг. Примерно самолетите на летището се насочват от кулата без да знаят един за друг. По този начин се получава връзка едно-към-много, която е за предпочитане. Защото се контролира по-лесно спрямо връзката много-към-много.

## Visitor Pattern

Дадена операция се извършва върху елементите на обект. Шаблона Visitor-а ви позволява да дефинирате нова операция без да променяте класовете върху, които оперират елементите.  

UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/Visitor.gif " Visitor Pattern")

## State Pattern

## Interpreter Pattern

## Specification Pattern
