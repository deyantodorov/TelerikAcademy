# Структурни шаблони - Structural Patterns

Структурните шаблони служат за:
* Описват начина за сглобяване на обекти и имплементират нова функционалност
* Лесно е да се проектира като се идентифицира елементарна връзка между обектите
* Всички тези шаблони са свързани с класовете и тяхното създаване
** Структурните шаблони за създаване на класове използват наследяване и интерфейси
** Структурните шаблони за дефинират начин да създадат обекти, за да се сдобият с нова функционалност

## Основните структурни шаблони са:

* Facade
* Composite
* Flyweight
* Proxy
* Decorator
* Adapter
* Bridge

## Facade Pattern 

Характеризира се с това, че е обект, който осигурява опростен интерфейс към голяма функционалност. Както са програмните библиотеките, които имат API, с който се случват различни задачи. Примерно в jQuery има $.ajax. Дистанционното на телевизор, с което се работи посредством 20-30 копчета, а не през платката на дистанционното и bloutooth-a на телевизора. 

* По този начин софтуерната библиотека се ползва по-лесно от клиента, по-разбираема е и по-лесно четима.
* Намалява се зависимостта на софтуерната библиотека към външен код, а се запазва принципа на клиента да се дава най-малко знания за начина на робата на библиотеката.
* Опаковат се слабо проектираните API в по-добри.

* UML диаграма
![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/facade.gif "Facade Pattern")

## Composite Pattern

Този шаблон ни позволява да изградим йерархична структура и да „питаме“ всеки елемент от дървовидната/йерархична структура дали е в правомощията му да изпълни дадена задача. Типична дървовидна структура е дадена фирмена структура, където директора е най-горе, под него са шефове на отдели и техните подчинени. След изграждането на структурата всеки един елемент може да бъде попитан дали да е в правомощията му да изпълни дадена задача. Да отпусне кредит, да изпълни задача и др.

При този шаблон всеки един елемент се характеризира като съставно листо от дървовидна структура. На опростено дървовидна структура може да се види на следната UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/Composite.png "Composite Pattern")

Конкретен пример в използването на Composite pattern може да се види на следната UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/Composite2.png "Composite Pattern")

IEmployee интерфейса дефинира операции, които всички работници трябва да могат да изпълняват

Worker класа са работници, които нямат подчинени и само могат да изпълняват метода ShowHappiness()

Supervisor класа са работници, които могат да управляват други работници
Ключовото в composite pattern-а е, че позволява да се създаде структура с общи операции.

## Flyweight pattern

Този шаблон, въпреки че не е широко разпространен, е много полезен в ситуации, при които компютърната памет е ограничена. Прилага се в ситуации, където имаме ограничение в броя на създадените обекти. Официалната дефиниция е: „Flyweight е общ обект, който може да се използва в различни контексти едновременно“. Т.е използва се много „лек“ обект, който се използва в различни части на приложението. Flyweight обекта може да се опише, чрез 2-те си състояния:

*Присъщо състояние – както и самото име подсказва при това състояние обекта е в натуралното си състояние и може да бъде споделян. Това състояние е независимо от контекста на Flyweight обекта. 

*Неприсъщо състояние – при това състояние обекта варира заедно с flyweight контекста и не може да бъде споделян.

За да се направи по-точна разлика между „присъщо“ и „неприсъщо“ състояние може да се разгледа следният пример. Процесора на думи трябва да се занимава с обекта буква. Ако погледнем на буквата от гледна точка на процесора нейното състояние ще е фона, стила, локацията. Така, че фона, стила и позицията са неприсъщи състояния, които не могат да се споделят. Съдържанието на буквите „а„, „б„  и т.н. може да бъде споделяно, защото е присъщо състояние. От тук можем да заключим, че ако срещнем случай, в който имаме множество обекти, които имат присъщо и неприсъщо състояние можем да приложим шаблона Flyweight. 
*Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/Flyweigth.jpg "Flyweight Pattern")

* FlyweightFactory – както може да се разбере и от името тук се управляват различните flyweights. При поискване на flyweight връща инстанция ако съществува или създава нов flyweight, добавя го към кеша на и го връща
*IFlyweight – това е интерфейс, които се имплементира от всеки flyweight. 
*ConcreteFlyweigth – това всъщност е flyweight и е споделяем.


## Proxy Pattern

Кога трябва да се използва Proxy шаблон, какви са ползите от неговото използване? Понякога се налага да достъпи обект, който е част от друго приложение, отделен домейн или се намира на много отдалечено място. 
Ако ни се налага да достъпваме такъв обект е нужно да се справяме с комуникационната логика между приложенията. От това стигаме до извода, че ако се налага да се комуникира с външно приложение освен логиката, която се залага за работа с данни трябва да се помисли и за логиката, която се залага при самата комуникация. Ако работата с данните и комуникацията се обвърже в един файл всичко това ще доведе до софтуер, който е труден за поддръжка. 
Цялата идея на Proxy шаблона е да имаме локален модул, който ще работи като отдалечения модул. По този начин приложението ще комуникира единствено с локалното копие, което от своя страна ще комуникира с отдалеченото. Цялата логика обвързана с комуникацията с отдалечения модул ще се сложи във вътрешният модул т.е. Proxy-то.  Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/Proxy.png "Proxy Pattern")

Реален пример за използването на Proxy Pattern-a може да бъде приложение, което се опитва да вземе информация от отдалечен сървър за цената на златото и т.н. Локалното Proxy ще има метод, който взема тези данни от отдалечения сървър. Този клас вътрешно ще си говори със сървъра и ще получава тези данни. Сървъра ще бъде обикновен уеб сървис, който ще взема тази информация от базата данни. В предоставения код могат да се видят повече детайли. 

## Decorator pattern

С помощта на този шаблон можем да добавим допълнителни възможности към даден обект динамично. Шаблона „Decorator“ ни осигурява гъвкава алтернатива от подкласове за разширяване на съществуващи функционалности.  UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/Decorator.png "Decorator Pattern")

В някой случай в нашето приложение ще ни се налага да създадем обект с базови функционалности по такъв начин, че някакви допълнителни функционалности могат да бъдат добавени допълнително. Например ако ни се налага да създадем обект за стрийм на информация е възможно да искаме да имплементираме криптиране. Това може да бъде направено лесно чрез подклас на съществуващия клас и ще имаме собствен начин за криптиране на информацията. Това решение със създаването на под-клас за криптиране е валидно, но когато се налага да има допълнителни опции и функционалности с този клас ситуацията е по-сложна. Ако ни се наложи да добавяме типове криптиране ситуацията е малко по-сложна. Когато допълнителната функционалност се налага да се добавя допълнително е още по-трудно. Ако се започне с логиката на под-класовете ще имаме толкова под-класове, колкото са и вариантите.

Точно в този случай Decorator шаблона е това, което ще ни свърши работа. По дефиниция той: „Добавя допълнителни отговорности върху обекта динамично“. 
Реален пример при използването на този шаблон може да е  система за разплащане на сладкарница. Сладкарницата има два основни продукта, но в зависимост от избора на продукта може да се добавят допълнителни екстри към всеки продукт.

## Adapter pattern

По дефиниция Adapter шаблона конвертира интрефейса на клас към друг интерфейс, който се очаква от клиента. По този начин позволява на класовете да работят заедно иначе това е невъзможно.  Така несъвместимите система успяват да заработят заедно. Като по-реален пример може да се посочи захранващо устройства на лаптоп, което е пригодено за САЩ, но трябва да работи в Европа. Какво се прави в този случай? Купува се ново захранващо устройство. Не! Купува се адаптер, който позволява ползването на същото захранващо устройство посредством адаптер в електрическата мрежа в Европа. Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/ Adapter.png "Adapter Pattern")

## Bridge pattern

Ако за първи път чуем за този шаблон, може да си помислим, че се има предвид две различни имплементации, но това не е вярно. Това е задачата на Adapter шаблона. Целта на Bridge шаблона е да раздели абстракцията от имлементацията. По дефиниция означава, че отделя абстракцията от имплементация по начин, по който двете могат да съществуват едновременно. 
Добър пример за онагледяване на този шаблон е plugins или driver. Ако имаме приложение, което може да използва специфичен драйвър, тогава имаме пример за Bridge шиблона. Класически пример, където може да се използва шаблона е видео настройките на екрана на дадена игра. Това дава опции на потребителя да стартира играта в различни режими. При избор на дадена опция се обръщаме към конкретна имплементация, която е независима от абстракцията за видео настройки. Примерна UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-StructuralPatterns/Diagrams/Bridge.png "Bridge Pattern")

Друг пример, който ще се покаже в кода е Smart TV, което може да чете от различни източници на информация – Cable TV, Satellite TV or IPTV.