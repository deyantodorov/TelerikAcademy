# ШАБЛОНИ ЗА СЪЗДАВАНЕ

## Използват се при инициализиране и конфигуриране на обекти и класове

### Creational Design Patterns

* Ползи:
- Отговарят за начина, по който се създават обекти
- Спомагат, за да се създадат обекти, който са нужни за конкретната ситуация
- Енкапсулират детайли свързани с всеки конкретен обект от системата
- Скриват имплементационни детайли свързани с конкретното създаване и комбиниране на класов

* Шаблони, които служат за създаване на обекти:
- Singleton
- Simple Factory
- Factory Method
- Abstract Factory
- Builder
- Prototype
- Fluent Interface
- Lazy initialization
- Object Pool
  
# SINGLETON PATTERN

Служи за създаването на един единствен обект от даден вид. За конкретния обект има само една единствена инстанция. Първоначално можем да се замислим каква е разликата между singleton pattern и обикновен статичен клас. Защо трябва да се имплементира singleton при положение, че може да се използва статичен клас? Истината е, че с инстанционен клас разработчика има повече възможности, защото класа е отворен за комуникация през интерфейси. 

При имплементацията на този шаблон трябва да се внимава, защото първоначално няма гаранция за „thread-safe“ операции. Т.е. ако имаме имплементиран шаблон и той работи с една нишка, и ако се поиска от друга нишка в същото време, когато се прави инстанция от първата нишка, той ще се инициализира отново, за да се предпазим от  това „явление“ трябва да се гарантира, че инстанцията на обекта ще е само една. Примерна имплементация може да се види в демото, където е създаден един Singleton клас и се стартират 20 извиквания към него на различни нишки.

UML диаграма Singleton pattern:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-CreationalPatterns/Diagrams/Singleton.png "Singleton pattern")

# SIMPLE FACTORY

С негова помощ получаваме инстанция на един от няколко възможни класа в зависимост от предоставената информация. Това означава, че класовете, които се връщат като резултат имат общ родител и методи, но всеки от тях изпълнява задачите по различен начин.

UML диаграма Simple Factory

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-CreationalPatterns/Diagrams/SimpleFactory.png "Simple Factory")

# FACTORY METHOD PATTERN

Factory method pattern-a ни позволява да енкапсулираме инстанцирането на конкретни типове. Ако се погледне в диаграмата по-долу може да се види, че абстрактния клас „Creator“ ни предоставя интерфейс с метод за създаването на обект. Този метод е по-известен като “factory method”. Всички останали методи, които са имплементирани в абстрактния клас служат, за да оперират върху продукти, които са резултат от factory method. Като официална дефиниция често може да се чуе, че Factory Method-a позволява подкласовете да решат какъв клас да инстанцират. Казва се „решат“ не защото шаблона позволява подкласовете да решават, а защото „Creator“ класа е така написан, че не знае какъв продукт може да се получи. Това се случва според решението на подкласовете.

UML диаграма Factory Method

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-CreationalPatterns/Diagrams/FactoryMethod.png "Factory Method")

# ABSTRACT FACTORY

Предоставя интерфейс за създаване на семейства от свързани или зависими обекти без да определя техните конкретни класове.

UML диаграма Abstract Factory

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-CreationalPatterns/Diagrams/AbstractFactory.png "Abstract Factory")

# BUILDER PATTERN

Този шаблон служи за построяването на сложни обекти като използва прости обекти и създава каквото е нужно стъпка по стъпка. Предоставя една от най-добрите възможности за създаването на обекти. Примерно ако имаме случай с ресторант за бързо хранене, където типичната храна е хамбургер и студена напитка. Хамбургера може да бъде вегетариански, пилешки и т.н. и е нужно да се опече. Студената напитка може да е кола или пепси и трябва да се сервира в бутилка.  Детайли могат да се видят на следната UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-CreationalPatterns/Diagrams/BuilderPattern.jpg "Builder pattern")

Този шаблон много прилича на Abstract Factory. Каква е разликата? Abstract factory ще върне инстанция директно, а Builder ще има директор, който ще инструктира Builder класа да построи различни части/свойства от обекта и накрая ще получите обекта. Abstract factory не пази история във връзка със създаването, а Builder пази референция към създаденият обект.

# PROTOTYPE PATTERN

Създава нов обект като клонира прототипа. Използва се вместо ключовата дума „new”. ICloneable интерфейса служи като Prototype. Определя вида обект, които да създаде използвайки инстанция на прототипа. Създава нов обект като копира този прототип.

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-CreationalPatterns/Diagrams/PrototypePattern.png "Prototype pattern")

# FLUENT INTERFACE

Най-просто казано chaining е пример за fluent interface. JavaScript e method chaining, а в C# LINQ . Примерно в C# method chaining се реализира, когато всеки метод връща обект и всички тези методи могат да бъдат навързани. 

# LAZY INITIALIZATION

Този шаблон може да се определи като тактика за забавяне създаването на обект, изчисляване на стойност или друга скъпа операция. Може да се нарече още Virtual Proxy, Lazy Load. ORMs навигацията са вид lazy load. 

# OBJECT POOL

При този шаблон се използват серия от инициализиране обекти, които са в „басейна“ вместо да се изтриват. Клиента на басейна поисква обекта, когато му е нужен и извършва операции върху него, когато му е нужен. Този шаблон е разпространен при игрите, когато създаването на различни обекти е по-бавна операция от ползването на готови такива.

Не позволява скъпи придобивания и освобождаване на ресурси като рециклира неизползвани ресурси. Позволява значително подобряване на производителността. * Примерно: 
    - При игрите в Unity обектите не се разрушават, а се преместват.
    - ADO.NET използва connection pooling, защото отварянето на конекции е скъпа операция.


