# ПОВЕДЕНЧЕСКИ ШАБЛОНИ

## Behavioral patterns

Целта на тези шаблони е да спомагат комуникацията/взаимодействието между обектите. Отговарят също и за възлагането на отговорности между обектите или енкапсулирането на поведение в обект делегирането на изпълнение. Увеличават гъвкавостта и се грижат за комуникацията между класовете.

### Основни поведенчески шаблони

- Chain of Responsibility
- Iterator
- Template Method
- Strategy
- Command
- Observer
- Memento
- Visitor
- State
- Interpreter
- Specification

## Chain of Responsibility

Този шаблон ни позволява да предадем молба от обект към следващ обект, докато молбата бива удовлетворена. Пример за това е прихващането на грешки, където ако грешката не е за текущия се прехвърля към по-старшия. По този начин се опростяват взаимовръзките между обектите. Отговорността е в дървовидна структура. Специфичното за тази структура е, че изпращача знае за само един получател. Получателят знае само за следващия получател, но не и за предходният изпращач. Първия получател, който има правомощие да се справи със задачата прекъсва веригата. Подредбата на обектите във веригата има значение. След разглеждането на структурните шаблони и шаблоните, които служат за създаване на обекти на пръв поглед започват да се появяват прилики. 

Примерно Chain of Reasonability прилича на Decorator, Composite, Proxy и е възможно първоначално да се объркаме, кога е нужно да се използва един или друг. 

Нека разгледаме следното сравнение: Decorator vs. Composite vs. Chain Of Responsibility vs. Proxy pattern.

**Composite** се използва, когато трябва да се създаде дървовидна структура, която е подобна на граф и трябва да се обходи рекурсивно. Т.е. при него имаме компоненти, които са или съставна част, т.е. composite, или са „листо“.

**Decorator** от своя страна изглежда много подобен на Composite, но в същото време е с напълно различна цел. Основната разлика между Composite и Decorator е размножението. Decorator-а има само един следващ обект след него, но също може да декорира други обект рекурсивно. Целта на Decorator шаблона е да промени входящите заявки и да ги препрати към наследниците си. Т.е. с него заявките първо се декорират преди да се изпратят към наследниците. 

**Chain of Responisibility** е много подобен на Decorator, но разликата е в това, че операцията може да спре на всеки един обект, които участва във веригата, но трябва да изпълнява търсеното условие.

**Proxy** е също много подобен на Decorator само, че може да има само едно Proxy преди изискването да пристигне към листото. Т.е. при този шаблон не може както при Decorator-a да имаме обект, които води към друг обект.

UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/ChainOfResponsibility.png "Chain of Resposibility Pattern")

## Iterator Pattern

Осигурява ни начин за достъпване на елементи от обект последователно. Без да се налага да се показва вътрешната репрезентация. UML диаграма:

![alt text](https://github.com/deyantodorov/TelerikAcademy/blob/master/High-Quality-Code/HW14.DesignPatterns-BehavioralPatterns/Diagrams/Iterator.gif "Iterator Pattern")

Участниците в този шаблон са:

- Iterator(Abstractor) – осигурява интерфейс за достъп и обхождане на елемнти

- ConcreteIterator(Iterator) – наследява Iterator и имплементира неговите интерфейси. Запазва състояние за конкретната позиция.

- Agregate (AbastractCollection) – дефинира интерфейс за създаване на Iterator обект

- ConcreteAggregate (Collection) – имплементира създаването на итератор, за да върне правилната инстанция на ConcreteIterator. 

В .NET итератор шаблона се ползва в IEnumerable. 

Често се среща при разработката са да се ползва колекция от обекти. Ако имаме колекция от обекти ще ни се наложи да обхождаме по някакъв начин тези обекти. Повечето езици осигуряват вградени начини за обхождане ако се ползват вградени типове колекции – List, LinkedList и др. Тези „контейнери“ на обекти ни позволяват да обхождаме обектите. Именно класовете на тези колекции са най-доброто обяснение за Iterator шаблона.

Идеята за Iterator шаблона е, че се разкача самата колекция от обекти от логиката за обхождане. Това позволява обекта на колекцията да е по-малък, защото няма нужда да се занимава със свързаните функционалности за обхождане. От гледна точка на клиента има и ясно разграничение между самата колекция и начина, по който се обхожда колекцията. Също и клиента не трябва да се занимава със следеното на броя обиколени обекти и колко още не са обиколени.